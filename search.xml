<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift 实现将自定义对象保存到 UserDefaults 中]]></title>
    <url>%2FSwift-%E5%AE%9E%E7%8E%B0%E5%B0%86%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E4%BF%9D%E5%AD%98%E5%88%B0-UserDefaults-%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[引言大家都知道，iOS 支持这些类型的对象，直接保存到 UserDefaults 中，比如 Int，String，Float，Double，Bool，URL，Data 或者这些类型的集合。 但是如果我们想要将自定义对象保存到 UserDefaults 中呢？ 看看苹果的说法： If you want to store any other type of object, you should typically archive it to create an instance of NSData如果要存储任何其他类型的对象，通常应该对其进行归档，来创建一个 NSData 实例。Apple Documentation 现在我们知道要保存自定义对象到 UserDefaults 中，就要把它转换为 Data 对象。基于此，我们可以使用 Codable 来做进一步的完善。 声明先定义一个协议 ObjectSavable，声明了两个方法，一个保存对象，另一个查询对象。 1234protocol ObjectSavable &#123; func setObject&lt;Object&gt;(_ object: Object, forKey: String) throws where Object: Encodable func getObject&lt;Object&gt;(forKey: String, castTo type: Object.Type) throws -&gt; Object where Object: Decodable&#125; setObject 方法接受一个类型符合 Encodable 协议的对象和一个想要与之关联的键； getObject 方法接受一个键，通过该键我们将从 UserDefaults 查询关联的对象，并接受一个符合 Decodable 协议的类型。为了传递类型本身，我们使用了元类型 A metatype type refers to the type of any type, including class types, structure types, enumeration types, and protocol types. 元类型指的是任何类型的类型，包括类类型、结构体类型、枚举类型和协议类型。 Apple Documentation 实现ObjectSavable 协议已经声明好了，通过给 UserDefaults 添加扩展，遵循 ObjectSavable 协议，并提供具体的实现： 123456789101112131415161718192021222324extension UserDefaults: ObjectSavable &#123; func setObject&lt;Object&gt;(_ object: Object, forKey: String) throws where Object: Encodable &#123; let encoder = JSONEncoder() do &#123; let data = try encoder.encode(object) set(data, forKey: forKey) &#125; catch &#123; throw ObjectSavableError.unableToEncode &#125; &#125; func getObject&lt;Object&gt;(forKey: String, castTo type: Object.Type) throws -&gt; Object where Object: Decodable &#123; guard let data = data(forKey: forKey) else &#123; throw ObjectSavableError.noValue &#125; let decoder = JSONDecoder() do &#123; let object = try decoder.decode(type, from: data) return object &#125; catch &#123; throw ObjectSavableError.unableToDecode &#125; &#125;&#125; 看下实现里都做了什么： setObject先创建了一个 JSONEncoder 实例，使用该实例将自定义对象转换为 Data 对象。然后把它保存到 UserDefaults 中。 getObject先使用 guard-let 保证是能取到数据的。然后创建一个 JSONDecoder 对象，最后，使用该实例将这个 Data 对象解码为给定的类型并返回它。 注意 如果上面的任何一个方法在任何一个步骤上失败了，它就会抛出一个相关的错误，提示开发人员可能出了什么问题。 为了方便管理这些错误，定义一个字符串枚举 ObjectSavableError 并遵循 LocalizedError 协议： 123456789enum ObjectSavableError: String, LocalizedError &#123; case unableToEncode = "Unable to encode object into data" case noValue = "No data object found for the given key" case unableToDecode = "Unable to decode object into given type" var errorDescription: String? &#123; rawValue &#125;&#125; 举个例子所有实现已经完成， 来个例子看看看效果： 先定义一个 Book 结构体： 12345struct Book: Codable &#123; var title: String var authorName: String var pageCount: Int&#125; 存储由于此方法在失败时会抛出错误，因此我们使用 do-try-catch 语句来捕捉错误 12345678let userDefaults = UserDefaults.standardlet playingItMyWay = Book(title: "《微信背后的产品观》", authorName: "龙哥", pageCount: 888)do &#123; try userDefaults.setObject(playingItMyWay, forKey: "WeChat")&#125; catch &#123; print(error.localizedDescription)&#125; 查询print(playingItMyWay) 语句将输出：Book(title: “《微信背后的产品观》”, authorName: “龙哥”, pageCount: 888) 12345678let userDefaults = UserDefaults.standarddo &#123; let playingItMyWay = try userDefaults.getObject(forKey: "WeChat", castTo: Book.self) print(playingItMyWay) &#125; catch &#123; print(error.localizedDescription)&#125; 总结如果觉得对你有帮助，不妨在项目中试试吧~ 本文首发掘金：Swift 实现将自定义对象保存到 UserDefaults 中 - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的 Self & Self.Type & self]]></title>
    <url>%2FSwift-%E4%B8%AD%E7%9A%84-Self-Self-Type-self%2F</url>
    <content type="text"><![CDATA[你可能在写代码的时候已经用过很多次 self 这个关键词了，但是你有没有想过什么是 self 呢？今天我们就来看看： 什么是 self、Self 和 Self.Type？ 都在什么情况下使用？ self这个大家用的比较多了，self 通常用于当你需要引用你当前所在范围内的对象时。所以，例如，如果在 Rocket 的实例方法中使用 self，在这种情况下，self 将是该 Rocket 的实例。这个很好理解~ 12345678struct Rocket &#123; func launch() &#123; print("10 秒内发射 \(self)") &#125;&#125;let rocket = Rocket()rocket.launch() //10 秒内发射 Rocket() 但是，如果要在类方法或静态方法中使用 self，该怎么办？在这种情况下，self 不能作为对实例的引用，因为没有实例，而 self 具有当前类型的值。这是因为静态方法和类方法存在于类型本身而不是实例上。 12345678910111213141516class Dog &#123; class func bark() &#123; print("\(self) 汪汪汪!") &#125;&#125;Dog.bark() //Dog 汪汪汪!struct Cat &#123; static func meow() &#123; print("\(self) 喵喵喵!") &#125;&#125;Cat.meow() // Cat 喵喵喵! 元类型还有个需要注意的地方。所有的值都应该有一个类型，包括 self。就像上面提到的，静态和类方法存在于类型上，所以在这种情况下，self 就拥有了一种类型：Self.Type。比如：Dog.Type 就保存所有 Dog 的类型值。 包含其他类型的类型称为元类型。 有点绕哈，简单来说，元类型 Dog.Type 不仅可以保存 Dog 类型的值，还可以保存它的所有子类的值。比如下面这个例子，其中 Labrador 是 Dog 的一个子类。 1234567891011class Dog &#123; class func bark() &#123; print("\(self) 汪汪汪!") &#125;&#125;class Labrador: Dog &#123;&#125;Labrador.bark() //Labrador 汪汪汪! 如果你想将 type 本身当做一个属性，或者将其传递到函数中，那么你也可以将 type 本身作为值使用。这时候，就可以这样用：Type.self。 1234567let dogType: Dog.Type = Labrador.selffunc saySomething(dog: Dog.Type) &#123; print("\(dog) 汪汪汪!")&#125;saySomething(dog: dogType) // Labrador 汪汪汪! Self最后，就是大写 s 开头的 Self。在创建工厂方法或从协议方法返回具体类型时，非常的有用： 123456789101112131415161718192021struct Rocket &#123; func launch() &#123; print("10 秒内发射 \(self)") &#125;&#125;extension Rocket &#123; static func makeRocket() -&gt; Self &#123; return Rocket() &#125;&#125;protocol Factory &#123; func make() -&gt; Self&#125;extension Rocket: Factory &#123; func make() -&gt; Rocket &#123; return Rocket() &#125;&#125; 本文首发掘金：Swift 中的 Self &amp; Self.Type &amp; self - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的关键字——Lazy]]></title>
    <url>%2FSwift-%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94%E2%80%94Lazy%2F</url>
    <content type="text"><![CDATA[引言相信大家在日常开发时，一定用过关键字 Lazy。那使用它有什么好处呢？什么时候才需要使用呢，让我们一起来看看吧~ 使用 Lazy 可以做很多事情： 实例化对象时不用给它的部分或全部成员初始值 调用之前，永远不会执行 存储计算值并防止重复计算 声明 Lazy只要在成员变量前面添加一个 Lazy 关键字，就可以将其声明为 lazy。惰性成员必须声明为 var。苹果的说法： You must always declare a lazy property as a variable (with the var keyword), because its initial value might not be retrieved until after instance initialization completes.必须始终将惰性属性声明为可变的(使用 var 关键字) ，因为在实例初始化完成之前，可能无法检索其初始值 由于所有常量在初始化结束时都必须有一个值，因此有必要将惰性属性声明为 var，举个🌰，代码中的 fullname 是一个常量，初始化时没有赋值，就报错了。另一个heavyComputation被声明为 lazy，初始化时没有赋值，就不会报错。这个大家应该都理解。 通过把属性声明为 lazy，就减轻了初始化的工作。这就是懒加载了。 懒加载另一个使用 lazy 的好处：加快初始化速度。作为开发者，我们都希望尽快能实例化我们的对象。因此，任何繁重的任务或计算，尽量避免在初始化时来做，也必须要避免。直到真正需要他们的时候，才去调用。让我们来看个例子。 从上面的例子可以明显看出，所有的计算都是在初始化 User 实例时完成的。这是因为 heavycalculation 被声明为 let 常量，需要在初始化结束时具有具体的值。因此，它是在同一时间计算。这并不是我们想要的。 我们把 heavycalculation 声明为 lazy，初始化时就不会计算它的值，直到第一次调用： 避免重复计算我们也可以通过计算属性达到懒加载的效果：注意下面的代码和上面的代码的区别： 从这个示例中可以明显看出，计算属性在初始化时也没有被计算。 但这是否意味着计算属性和 lazy 属性相似呢？虽然看起来很相似，但是他们有一个非常基本的区别，这就使得 lazy 更加有用。 让我们试试多次访问计算属性，看看会发生什么。 从代码中发现，当我们多次访问计算属性ー heavycalculation 时，每次访问都会计算一遍(这里是两次)。 再来看看把 heavycalculation 声明为 lazy 时，再多次调用，看看会发生什么： 这次只计算该属性一次。这意味着，在第一次计算值之后，它的值就会被保存下来以备下次使用，并且与使用计算属性的情况不同，声明为 lazy 后，不会重复计算值。 因此，根据上面的示例，我们可以很容易地确定 lazy 属性存储值，并且不会在每次访问它们时进行计算。因此，节省了大量的处理器资源和时间。 使用注意事项在理解了懒惰的工作原理之后，现在我们必须理解它的用法，并且在使用时要小心谨慎。 注意因为 lazy 属性只计算一次，因此内部逻辑不能依赖于其他变量，尤其是那些频繁变化的变量。这是因为，在第一次计算后，当其他的变量的值变化后，lazy 属性的值不能同步更新，使用时就会出错。 此外，lazy 不是线程安全的。这意味着当我们在不同的线程上访问同一个变量时，可能会得到不同的值。苹果的说法： If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there’s no guarantee that the property will be initialized only once.如果标记为 lazy 修饰符的属性被多个线程同时访问，而该属性尚未初始化，则不能保证该属性只初始化一次。 这表明，过多使用 lazy 实际上可能会产意想不到的错误。但有些啥时候，我们可能想懒散地做事。由于 UI 总是在主线程上刷新，这使得它成为懒加载的一个很好的选项。 总结lazy 大家都很熟悉了，但在平时开发时，也不能为了用而用，还是要根据实际情况，酌情使用。同时注意多线程的坑。 本文首发掘金：Swift 中的关键字——Lazy - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的链表]]></title>
    <url>%2FSwift-%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[引言数据结构是用于在计算机中组织和存储数据的容器，以便我们能够有效地执行操作。它们是编程最基本的组成部分。最知名和最常用的数据结构，除了 数组、 栈 和 队列等，还有一个非常有用的数据结构–链表。不过，Swift 没有提供内置的链表结构，所以，今天我们就来一步步的实现一个。 什么是单链表 链表是链接节点的列表。节点是一个单独的元素，它包含一个泛型值和一个指向下一个节点的指针。链表有以下几种类型: 单链表 每个节点只有一个指向下一个节点的指针。操作只能向一个方向传递 双向链表 每个节点有两个指针，一个指向下一个节点，另一个指向前一个节点。操作可以向前和向后两个方向进行 循环链表 最后一个节点的下一个指针指向第一个节点，第一个节点的上一个指针指向最后一个节点 今天我们来实现 Swift 中的单链表。 NodeNode 必须定义为 Class。因为设计到引用，所以它需要是引用类型，Node 类有两个属性： value 存储节点实际值的泛型数据类型 next 指向下一个节点的指针 123456789class Node&lt;T&gt; &#123; var value: T var next: Node&lt;T&gt;? init(value: T, next: Node&lt;T&gt;? = nil) &#123; self.value = value self.next = next &#125;&#125; 链表与 Node 不同，链表是一种值类型，定义为 Struct。默认情况下，链表有三个基本属性: head链表的第一个节点 tail链表的最后一个节点 isEmpty链表是否为空 当然，你可以根据需要添加其他属性，例如: count链表的节点个数 description链表的描述文本 12345678struct LinkedList&lt;T&gt; &#123; var head: Node&lt;T&gt;? var tail: Node&lt;T&gt;? var isEmpty: Bool &#123; head == nil &#125; init() &#123;&#125;&#125; 与栈和队列不同，链表不包含可以直接调用和使用的数据集合。列表中的所有节点都必须链接到下一个可用的节点(如果有的话)。 Push把数据添加到链表头部，这意味着当前的 head 将被替换为新节点，新节点将成为链表的 head。 123456789101112struct LinkedList&lt;T&gt; &#123; ... mutating func push(_ value: T) &#123; head = Node(value: value, next: head) if tail == nil &#123; tail = head &#125; &#125;&#125; 通过调用 push(_ value: T) ，我们用该值创建一个新节点，并使新节点指向原来的 head。然后我们用新节点替换 head，这样原来的 head 就成为链表的第二个节点。 Append与 push 类似，我们将数据添加到链表的末尾。这意味着当前的尾部将被替换为新节点，新节点将成为新的尾部。 12345678910struct LinkedList&lt;T&gt; &#123; ... mutating func append(_ value: T) &#123; let node = Node(value: value) tail?.next = node tail = node &#125;&#125; 通过调用 append(_ value: T) ，我们创建了一个新节点，并将原来的尾部指向新节点。最后，我们将原来的 tail 替换为新的节点，因此原来的 tail 成为列表的倒数第二个节点。新的节点将成为新的尾部 Node At链表不能通过下标索引取值，因此我们不能像数组 array[0] 那样读取数据集合。 1234567891011121314struct LinkedList&lt;T&gt; &#123; ... func node(at index: Int) -&gt; Node&lt;T&gt;? &#123; var currentIndex = 0 var currentNode = head while currentNode != nil &amp;&amp; currentIndex &lt; index &#123; currentNode = currentNode?.next currentIndex += 1 &#125; return currentNode &#125;&#125; 为了获取某个索引对应的 Node，需要遍历。 Insert正如我之前所说，链表不能通过索引下标取值。链表只知道哪个节点链接到哪个节点。为了告诉链表在特定位置插入一个节点，我们需要找到链接到该位置的节点。v需要用到上面的函数：node(at index: Int) -&gt; Node&lt;T&gt;? 123456789struct LinkedList&lt;T&gt; &#123; ... func insert(_ value: T, after index: Int) &#123; guard let node = node(at: index) else &#123; return &#125; node.next = Node(value: value, next: node.next) &#125;&#125; 首先，我们必须找到位于给定位置的节点。我们接下来让它指向新节点，新节点指向原来的下一个节点。 Pop我们将 head 从列表中删除，这样第二个节点将成为 head: 1234567891011121314struct LinkedList&lt;T&gt; &#123; ... mutating func pop() -&gt; T? &#123; defer &#123; head = head?.next if isEmpty &#123; tail = nil &#125; &#125; return head?.value &#125;&#125; 返回原来的 head 的值，并用原来的下个节点替换原来的 head，这样原来的下个节点就成为了 head。 Remove Last与 pop() 类似，这是删除链表的尾部，因此倒数第二个节点将成为尾部。 123456789101112131415161718192021struct LinkedList&lt;T&gt; &#123; ... mutating func removeLast() -&gt; T? &#123; guard let head = head else &#123; return nil &#125; guard let _ = head.next else &#123; return pop() &#125; var previousNode = head var currentNode = head while let next = currentNode.next &#123; previousNode = currentNode currentNode = next &#125; previousNode.next = nil tail = previousNode return currentNode.value &#125;&#125; 但与 pop() 不同的是，去掉尾部节点有点复杂，因为尾部不知道前一个节点是谁。我们需要遍历链表以找到尾部之前的节点，并将其设置为尾部。 如果头部是nil，意味着该列表是空的，我们没有什么要删除，然后返回nil 如果head.next是nil，这意味着只有一个节点在链表中，然后删除头 循环遍历列表，找到尾部之前的节点，并将其设置为尾部 Remove After与 insert(_ value: T, after index: Int) 类似，我们需要先找到待删除位置的节点。 123456789101112131415struct LinkedList&lt;T&gt; &#123; ... mutating func remove(after index: Int) -&gt; T? &#123; guard let node = node(at: index) else &#123; return nil &#125; defer &#123; if node.next === tail &#123; tail = node &#125; node.next = node.next?.next &#125; return node.next?.value &#125;&#125; 移除指定索引处的节点有点棘手，因此我们基本上只是跳过一个节点，然后指向那个节点之后的节点。 总结这些是单链表通常具有的基本属性和函数。当然，你也可以在这些基础上添加其他属性和函数。 本文首发掘金：Swift 中的链表 - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说 Swift 中的集合协议--Pt.2]]></title>
    <url>%2F%E8%AF%B4%E8%AF%B4-Swift-%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E5%8D%8F%E8%AE%AE-Pt-2%2F</url>
    <content type="text"><![CDATA[引言在上篇文章 说说 Swift 中的集合协议–Pt.1 中，我们把集合树中的 IteratorProtocol、Sequence、Collection 过了一遍，今天就来探索一下剩余的部分。 BidirectionalCollectionBidirectionalCollection 支持向后和向前遍历。它可以从任何有效索引(不包括集合的 startIndex)向后遍历。因此，它可以提供一些额外的操作，比如，可以快速的访问集合的最后一个元素。此外，它对某些序列和集合方法有更高效的实现，比如，reverse()。协议定义也很简单~ 123protocol BidirectionalCollection: Collection &#123; func index(before i: Index) -&gt; Index&#125; 因为 BidirectionalCollection 可以向后遍历，所以可以改进 reversed() 方法的实现。reversed() 最初是在 Sequence 里实现的，返回类型为 Array\，O(n) 的时间复杂度。 BidirectionalCollection 实现了 reverse()，它不会去读取 Sequence 元素，而是返回一个名为 ReversedCollection 的新类型，该类型包装了原始的 Collection。ReversedCollection 将自己的索引转换为基本集合的索引，并根据需要从基本集合中访问元素。创建 ReversedCollection 是 O(1) 的时间复杂度。 由于 Sequence 实现的返回类型与 BidirectionalCollection 的返回类型不同，我们可以看到在 Xcode 有两个 reversed() 的自动提示。 如果没有声明变量的类型，则默认得到的是 ReversedCollection 类型，所以我们可以通过显式声明变量的类型，告诉编译器我们想要哪个reversed()方法。 现在我们可以从两端访问元素，但还不能改变指定索引处的值，该功能由 MutableCollection 提供。 MutableCollection如果我们尝试使用下标修改集合中的任何值，将会出现编译错误。集合只为我们提供对其元素的下标读访问。为了能写访问，我们需要遵循 MutableCollection。协议定义很简单~ 123protocol MutableCollection: Collection &#123; subscript(position: Index) -&gt; Element &#123; get set &#125;&#125; MutableCollection 看起来像是一个简单的附加功能，但是它提供了一些有用的方法，比如交换两个索引处的元素：swapAt(_: :) 和直接修集合本身的 reverse()。 在实现 MutableCollection 时需要注意，下标赋值不应该改变集合本身的长度。这就是为什么 String 不符合 MutableCollection 的原因。使用下标替换字符可以改变字符串的长度，因为字符本身没有固定的长度。 正式因为有长度限制，所以 MutableCollection 不提供诸如 remove(_:)、 append(_:)、 insert(_: at:) 等方法，这些方法通常与单词 mutable 相关联。 Collection 可以让我们使用下标访问任何元素，但访问的时间不是固定的。这里就引出了 RandomAccessCollection 协议，它可以让我们以固定的时间访问集合中的任何元素。 RandomAccessCollection它是一个支持快速随机访问元素的集合。RandomAccessCollections 可以以 O(1) 的时间复杂度把下标移动到任何距离及计算两个索引之间的距离。因此，RandomAccessCollection 和 BidirectionalCollection 之间的根本区别在于，索引移动或索引间的计算等操作，RandomAccessCollection 效率更高。协议定义非常简单~ 12public protocol RandomAccessCollection: BidirectionalCollectionwhere SubSequence: RandomAccessCollection, Indices: RandomAccessCollection &#123; &#125; 除了要求 BidirectionalCollection 的子序列和索引类型本身是 RandomAccessCollection 外，它没有增加额外的实现。 遵循 RandomAccessCollection，虽然不能解锁一些额外技能，但它确实提高了某些现有算法的性能，比如 dropFirst(_:)、 dropLast(_:)、prefix(_:), suffix(_:)，这些都是O(1)时间复杂度。最重要的是，访问 count 属性的时间复杂度为 O(1) ，而不需要对整个集合进行迭代。如果我们的 RandomAccessCollection 也符合 MutableCollection，那么我们也可以调用 sort() 和 shuffle() 方法直接修改集合本身。 尽管遵循 MutableCollections的集合是可变集合，但仍然不能调用像 insert(_: at:) 这样的改变长度的函数。想改变长度，就得遵循 RangeReplaceableCollection 协议。 RangeReplaceableCollectionRangeReplaceableCollection 支持用另一个集合的元素替换任意范围的元素。听起来有点像 MutableCollection，但是这里的关键区别是新集合不需要与被替换的集合具有相同的长度。协议定义很简单~ 12345protocol RangeReplaceableCollection: Collection &#123; init() mutating func replaceSubrange&lt;C&gt;(_ subrange: Range&lt;Index&gt;, with newElements: C) where C: Collection, C.Element == Element&#125; 这个方法解锁了一系列新功能。我们可以在任何索引处插入一个新的集合，通过 index..&lt;index 作为子区域。我们可以在最后添加一个集合，完成在 endIndex 插入集合并从集合中删除所有元素。 由于 rangereplaceablection 可以修改集合的长度，因此 String 可以安全地遵循它。 Dictionaries and Sets Set 遵循了 Collection 协议，这使得它们可以访问类似 firstIndex(of:) 等方法。对于像 Set 这样的无序集合，此方法虽然没啥意义，但是我猜想，与一些 API 不一致性相比，遵循 Collection 的好处更大。 Dictionary 也遵循了 Collection 协议。基于使用键作为下标访问值的方式。Dictionary 实际上使用内部类型作为它们的 Index，而它们的 Element 类型是 tuple(Key，Value)。Dictionary 实际上有两个下标，一个基于内部索引来满足 Collection 协议的要求，另一个使用我们熟悉的 Key。 结语以上就是集合协议的全部内容了，通过这两篇文章的介绍，相信大家也对集合协议有了一个整体上的认识，至少知道了集合可以遍历是遵循了什么协议，集合可以访问元素是遵循了什么协议，可以插入、删除元素是遵循了什么协议等等。 本文首发掘金：说说 Swift 中的集合协议–Pt.2 - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说 Swift 中的集合协议--Pt.1]]></title>
    <url>%2F%E8%AF%B4%E8%AF%B4-Swift-%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E5%8D%8F%E8%AE%AE-Pt-1%2F</url>
    <content type="text"><![CDATA[引言在 Swift 中，有一块内容，我一直都不太愿意去学，那就是全系列的集合类型。那现在为啥去看了呢，因为卷 主要原因是标准库中提供的具体实现–数组、集合和字典–能覆盖日常开发 99% 的情况。还有一个更重要的原因—-协议太多了！ 更不用说 Swift 5.5 了。介绍了一个全新的基于 AsyncSequence 的协议家族，不过这篇文章中不会涉及。 那就让我们试着弄清楚每个协议的作用，以及为什么我们需要这么多协议。下面的图就展示了全系列的集合协议，我将从上到下依次介绍： IteratorProtocol一次提供一个序列值的类型。该协议与 Sequence 协议紧密相连，后面就会看到。序列通过创建迭代器来提供对其元素的访问，迭代器跟踪其迭代过程，并随着序列的前进每次返回一个元素。协议的定义如下: 1234public protocol IteratorProtocol &#123; associatedtype Element mutating func next() -&gt; Element?&#125; 一个名为 next() 的方法，返回下一个元素或 nil。它被标记为 mutating，这样就可以更新他们的内部状态，为下一次调用 next() 做准备。如果实现没有返回 nil，迭代器可以无限地生成值。我们很少直接创建迭代器，因为 Swift 中的序有一种更为常用的方法。不过，让我们创建一个具体的迭代器来看看它是如何工作的。 12345678910111213141516171819struct DoublingIterator: IteratorProtocol &#123; var value: Int var limit: Int? = nil mutating func next() -&gt; Int? &#123; if let l = limit, value &gt; l &#123; return nil &#125; else &#123; let current = value value *= 2 return current &#125; &#125;&#125;var doublingIterator = DoublingIterator(value: 1, limit: 1024)while let value = doublingIterator.next() &#123; print(value)&#125; 调用一个简单的迭代器，每次调用 next()，值增加一倍。如果我们初始化 DoublingIterator 时，limit 传 nil，迭代器将永远运行，直到值超出最大值。 Sequence可以用对其元素进行顺序迭代访问的类型。序列就是一系列的值，每次我们都可以访问一个。虽然看起来很简单，但是这种能力使我们能够进行大量的操作，而且可以对任何序列执行这些操作。Sequence 协议为这些常见操作提供了缺省实现。在研究这些操作之前，让我们先看一下协议定义~ 12345public protocol Sequence &#123; associatedtype Element associatedtype Iterator: IteratorProtocol where Iterator.Element == Element func makeIterator() -&gt; some IteratorProtocol&#125; 序列通过它的 makeIterator() 方法和关联的类型来确保迭代器的 Element 类型和序列匹配。让我们使用 DoublingIterator 创建一个具体的 DoublingSequence: 12345678910111213141516struct DoublingSequence: Sequence &#123; var value: Int var limit: Int? = nil func makeIterator() -&gt; DoublingIterator &#123; DoublingIterator(value: value, limit: limit) &#125;&#125;let doubler = DoublingSequence(value: 1, limit: 1024)for value in doubler &#123; print(value)&#125;print(doubler.contains &#123; $0 == 512 &#125;) // trueprint(doubler.reduce(0, +)) // 2047 仅仅通过遵循 Sequence，我们的具体类型就获得了 for-in 和一些其他操作的能力，如 map、 filter、 reduce 等。Sequence 还提供了 dropFirst(_:)、 dropLast(_:) 等方法。但是，在序列级别，这些方法的实现受到一次迭代一个元素的约束。这反映了它们的时间复杂度—— dropFirst(_:)是 O(k)，其中 k 是要删除的元素数，dropLast(_:) 是 O(n)，其中 n 是按顺序排列的元素总数。dropLast(_:) 与 dropFirst(_:)不同，它要求序列是有限的。 在使用 Sequences 时需要注意一些事情 序列不能保证多次迭代产生想要的结果。由实现类型决定如何处理对已经遍历过一次的序列的迭代 序列提供的迭代器应保证时间复杂度为 O(1)。它对元素访问没有其他要求。因此，除非另有文档说明，否则应该将遍历序列的方法视为 O(n) 给定一个元素，Sequence 允许我们移动到下一个元素。为了能够移动到任何元素(虽然不能保证移动的世界是常量时间)，我们需要 Collection。 Collection一个序列，其元素可以通过下标被多次访问。当我们使用数组、字典或集合时，受益于 Collection 协议声明和实现的操作。除了从 Sequence 协议继承的操作之外，我们还可以访问集合中特定位置的元素的方法。Collection 的协议定义如下： 12345678protocol Collection: Sequence &#123; associatedtype Index: Comparable var startIndex: Index &#123; get &#125; var endIndex: Index &#123; get &#125; subscript(position: Index) -&gt; Element &#123; get &#125; func index(after i: Index) -&gt; Index&#125; 由于多次遍历和通过索引下标访问的需要，一个集合不能延迟地计算它的值，也不能是无限的。这与 Sequences 不同，Sequences 可以通过当前对 next() 的调用更新内部状态，为下一次调用做准备。还要注意，associatedtype Index 不是 Int 类型，而是符合 Comparable 的任何类型。 结语在下篇文章中，我们继续探索剩余的部分~ 说说 Swift 中的集合协议–Pt.1 - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 的拼写检查，你开启了吗？]]></title>
    <url>%2FXcode-%E7%9A%84%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%EF%BC%8C%E4%BD%A0%E5%BC%80%E5%90%AF%E4%BA%86%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[引言作为一名开发人员，当我们编写代码时，我们会更多地关注逻辑和算法，而不是拼写和语法。但它也是我们编码的一个重要部分，特别是当我们从注释生成文档的时候。 拼写检查帮助我们找出拼写错误，让我们有更多的时间关注代码逻辑。 拼写检查能识别什么答案就是代码中与Spelling and Grammer相关的所有内容 变量名 方法 类 注释 字符串的字面量(包括本地化) 先来看一段代码： 在上面的代码中，包括类、方法、变量和注释，但没有启用Spelling and Grammer。猛一看去，好像没啥问题，但如果我们仔细检查，就会发现很多拼写错误。 现在让我们启用Spelling and Grammer，看看会发生什么- 在上面的代码中我们可以看到，当我们启用拼写检查时，它能检测到所有的拼写错误，并用红色高亮显示。现在我们就省去了找错误的时间，可以直接去修改了。 如何开启 Edit &gt; Format &gt; Spelling and Grammar 可以看到有三个可用的选项，我们依次来看下： Check Spelling While Typing启用后，会把项目中的所有输入错误一次性、全部以红色高亮显示，就像上面的例子一样。 另外，开启这个选项后，还可以选中要修改的单词，然后右键，菜单中会出现 Xcode 建议的单词。 Check Document Now它将在当前文件中逐个显示输入错误。为了检查当前文件中的所有错误，可以重复这个命令Edit &gt; Format &gt; Spelling and Grammar &gt; Check Document Now 或者使用快捷键command 和分号（;）的组合 Show Spelling and Grammar它会打开所有建议的更改。我们可以单击其中任何一个进行替换。使用命令Edit &gt; Format &gt; Spelling and Grammar &gt; Show Spelling and Grammar 或者使用快捷键command 和冒号（:）的组合 Learn Spelling 和 Ignore Spelling有时候我们需要使用一些在系统词典中没有定义的独特词汇，比如应用程序前缀、开发者名称、公司名称等。Xcode 也会检查这些单词的错误。 所以就用Learn Spelling或者Ignore Spelling处理这些特殊的单词。 通过菜单右键选中要处理的单词 通过 command + ： 结语快去探索一下 Edit &gt; Format &gt; Spelling and Grammar 下面的三个选项吧~ 本文首发掘金：Xcode 的拼写检查，你开启了吗？ - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能不知道的 Swift 开发小技巧——Pt.2]]></title>
    <url>%2F%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-Swift-%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94Pt-2%2F</url>
    <content type="text"><![CDATA[往期文章： 你可能不知道的 Swift 开发小技巧——Pt.1 对数组进行分组假如有一组文章，要把这些文章按照 category 进行分组，可以利用 Pt.1中提到的，给字典的某个 key 设置默认值的技巧，实现如下： 1234567891011121314151617struct Article &#123; let title: String let category: String&#125;let articles = [ Article(title: "标题1", category: "Swift"), Article(title: "标题2", category: "Swift"), Article(title: "标题3", category: "Objective-C"), Article(title: "标题4", category: "Objective-C"),]var groupByCategory = [String : [Article]]()for article in articles &#123; groupByCategory[article.category, default: []].append(article)&#125;print(groupByCategory) 实际上我们可以使用 Dictionary 的内置初始化方法来简化上面的 for 循环： 12let groupByCategory = Dictionary(grouping: articles, by: &#123;$0.category&#125;)print(groupByCategory) 检查所有集合项是否满足条件假如有这么需求：给定一组表示年龄的整型数组，求他们的平均年龄。计算总和，除以数量，so easy~ 然而并不是每个整数都能表示年龄，因为传入的值有可能小于等于 0。对于输入参数：年龄数组，是不可控的。因此遇到不符合实际的值，需要抛出错误。通常会这么实现： 1234567891011121314151617func findAverage(ages: [Int]) -&gt; CGFloat &#123; var isAgeValid = true for age in ages &#123; if age &lt;= 0 &#123; isAgeValid = false break &#125; &#125; guard isAgeValid else &#123; fatalError("所有的年龄必须大于 0") &#125; let sum = ages.reduce(0, +) let count = ages.count return CGFloat(sum) / CGFloat(count)&#125;findAverage(ages: [22, 25, 26, 28, 30]) 我们可以使用 Array 的方法：allSatisfy(_:)来简化 for 循环代码： 123456789101112func findAverage(ages: [Int]) -&gt; Double &#123; let isAgeValid = ages.allSatisfy &#123; $0 &gt; 0 &#125; guard isAgeValid else &#123; fatalError("所有的年龄必须大于 0") &#125; let sum = ages.reduce(0, +) let count = ages.count return Double(sum) / Double(count)&#125;findAverage(ages: [22, 25, 26, 28, 30]) 保留 Struct 的默认初始化器大家都知道，Swift 中的 Struct 是值类型，自带一个成员初始化器。 不知道大家有没有遇到这样的情况，需要自定义 Struct 的初始化器，又想保留默认的初始化器，但是自定义后，默认的初始化器就消失了。 先看下默认的初始化器： 自定义初始化器后，默认初始化器就消失了： 想同时保留自定义的和默认的，就得祭出 extension 大法了： 过滤数组中的 nil提到过滤，第一反应可能就是 filter(_:)： 123let x = [1, nil, 2, 4]let y = x.filter &#123; $0 != nil &#125; 虽然也可以，但不不是那么好。上面的 x 的类型 [Int?]，y 也是。有什么问题？问题是，我们已经明确知道 y 里面不会包含 nil 值了，但编译器不知道，所以在遍历 y 时，依然需要对其中的元素进行解包： 12345let x = [1, nil, 2, 4]let y = x.filter &#123; $0 != nil &#125;for item in y &#123; print("item is \(item!)")&#125; 更好的做法是使用 compactMap(_:)： 123let x = [1, nil, 2, 4]let y = x.compactMap &#123; $0 &#125; 这时候 x 是 [Int?] 的类型，y 是 [Int] 的类型。 zip假如需要同时遍历两个数组，你会怎么做？在我知道 zip 之前，我通常都是这么做： 12345678let array1 = ["title1", "title2", "title3", "title4"]let array2 = ["value1", "value2", "value3", "value4", "value5"]let count = min(array1.count, array2.count)for i in 0..&lt;count &#123; let title = array1[i] let value = array2[i]&#125; 再来看看 zip 的用法，zip 可以组合两个序列，而且会进行边界检查： 123456789for (title,value) in zip(array1, array2) &#123; print("\(title)---\(value)")&#125;//输出结果title1---value1title2---value2title3---value3title4---value4 结语 使用 Dictionary 的 init(grouping:by:) 方法对数组进行分组 使用 Array 的 allSatisfy(_:) 方法检查所有集合项是否满足条件 通过 extension 添加自定义初始化器从而保留默认初始化器 使用 compactMap(_:) 过滤数组中的 nil 使用 zip 组合两个集合 往期文章： 你可能不知道的 Swift 开发小技巧——Pt.1 以上就是平时在项目中使用比较多的 Swift 小技巧啦，我也会继续总结更多的小技巧和大家进行分享~ 如果大家遇到以前没用到过的，不妨动手试试吧~ 本文首发掘金：你可能不知道的 Swift 开发小技巧——Pt.2 - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能不知道的 Swift 开发小技巧——Pt.1]]></title>
    <url>%2F%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-Swift-%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94Pt-1%2F</url>
    <content type="text"><![CDATA[引言在我一开始写 Swift 代码时，总是显的不简洁，没有充分发挥 Swift 的特性。随着写的时间长了，也总结了一些 Swift 开发的小技巧，让代码看起来更加简洁和高大上。 内容一共分为两篇文章，我们先来看第一篇~ 使用内置函数现在有个整型数组，我们想计算数组内所有数字之和。第一反应可能就是 for 循环，于是就写出了下面的代码： 123456let numbers = [2021, 11, 12]var sum = 0for number in numbers &#123; sum += number&#125;print(sum) //2044 当然，这么写也没啥毛病，但我们可以使用 reduce(_:_:)把 for 循环简化成一行： 123let numbers = [2021, 11, 12]let sum = numbers.reduce(0, +)print(sum) //2044 上面这段代码就等价于 0 + 2021 + 11 + 12reduce 的第一个参数 0 是初始值，相当于上面 for 循环代码中的 var sum = 0第二个参数接受一个闭包，这就给了我们在闭包里为所欲为的机会了。 除了reduce(_:_:)，Swift 还提供了其他的内置函数，比如filter(_:)、map(_:)、flatMap(_:)、firstIndex(where:)等等。更多的大家可以 command+shift+0 打开开发文档查看。 省略 return 关键字如果一个函数或闭包只有一行代码，那就可以把 return 关键字省略掉。而且，如果你喜欢的话，可以把所有代码放在一行： 12345func makeGreeting(withName name: String) -&gt; String &#123; "求点赞, \(name)"&#125;func makeGreeting(withName name: String) -&gt; String &#123; "求点赞, \(name)" &#125; 简化闭包12345struct Person &#123; var name: String var age: Int ...&#125; 假如有个 Persons 数组，里面是 Person 对象，现在要筛选出大于 18 岁的 Person，用前面提到的filter(_:)，可以这么写： 12345678910let person1 = Person(name: "JieJie", age: 20)let person2 = Person(name: "Faker", age: 25)let person3 = Person(name: "JakeyLove", age: 30)let person4 = Person(name: "JinX", age: 10)let persons = [person1, person2, person3, person4]let result = persons.filter &#123; person in person.age &gt; 18&#125;print(result.map&#123; $0.name &#125;) //["JieJie", "Faker", "JakeyLove"] Swift 自动为内联函数提供了参数名称缩写功能，所以上面的 filter 语句可以简化成： 1let result = persons.filter&#123; $0.age &gt; 18 &#125; 检查数组是否越界还是上面的 persons 数组，数量不固定，假如我们要对上面的 persons 数组抽奖，第 6 个人中奖，如果人数没有达到 6，那就延长抽奖日期，通常可能会这么做： 123456let index = 6if index &gt;= 0 &amp;&amp; index &lt; persons.count &#123; print("恭喜 \(persons[index].name) 中奖")&#125; else &#123; print("延长抽奖日期")&#125; 上面这个写法就显的很普通了，我们用数组的indices属性把它变得高大上： 12345if persons.indices.contains(index) &#123; print("恭喜 \(persons[index].name) 中奖")&#125; else &#123; print("延长抽奖日期")&#125; 默认值大家都知道可以用??为可选变量设置默认值，其实在 Swift 中，还有更多的地方可以设置默认值，比如： 为函数参数设置默认值 为 dictionary 的某个 key 设置默认值 先来看看为函数参数设置默认值，设置后，该参数在调用时就可以省略： 1234567func greet(name: String = "World") -&gt; String &#123; "Hello,\(name)" &#125;greet("World!!!") //Hello,World!!!greet() //Hello,World 再来看看为 dictionary 的某个 key 设置默认值。 假如有个 names 数组，里面存放的是人名，现在要写个函数返回出现次数最多的人名。一种实现方式如下： 12345678910111213141516171819202122232425let names = ["小张", "小李", "小张", "小李", "小张", "小王"]func findMostCountName(inNames names: [String]) -&gt; String &#123; var occurrenceFor: [String : Int] = [:] for name in names &#123; if let count = occurrenceFor[name] &#123; occurrenceFor[name] = count + 1 &#125; else &#123; occurrenceFor[name] = 1 &#125; &#125; var maxCount = 0 var result = "" for (name, count) in occurrenceFor &#123; if count &gt; maxCount &#123; maxCount = count result = name &#125; &#125; return result&#125;let name = findMostCountName(inNames: names)print(name) //小张 再来看看给 dictionary：occurrenceFor 的 key 设置默认值的效果： 12345678910111213141516func findMostCountName(inNames names: [String]) -&gt; String &#123; var occurrenceFor: [String : Int] = [:] for name in names &#123; occurrenceFor[name, default: 0] += 1 //如果 key 存在，返回对应的 value；否则返回 0 &#125; var maxCount = 0 var result = "" for (name, count) in occurrenceFor &#123; if count &gt; maxCount &#123; maxCount = count result = name &#125; &#125; return result&#125; 可见，给 dictionary 键设置默认值可以使代码看起来更加整洁。只需一行代码，就可以替换掉 if-else 语句。 检查变量是否在两个数之间假如有个字段：年龄，现在要判断它是不是在 18 岁到 32 岁之间。通常我们会这么做： 12345let age = 23if age &gt;= 18 &amp;&amp; age &lt;= 32 &#123; print("符合要求")&#125; 可能觉得像上面这么写没啥问题，但再来看看下面这个： 12345let age = 23if age &lt;= 18 &amp;&amp; age &gt;= 32 &#123; print("符合要求")&#125; 是不是很像，但这个时候 print 语句永远也不会执行。大家在读这两个 if 语句的时候有什么感受？是不是需要在大脑中有那么一下停顿，来思考符不符合条件。这就造成不易读而且容易出错。 在 Swift 中提供了更易读、简便的方法来实现： 123456789let age = 23if (18...32).contains(age) &#123; print("符合要求")&#125;if (18...32) ~= age &#123; print("符合要求")&#125; 结语 尽量使用内置函数替代 for 循环 只有一行代码的函数省略 return 关键字 闭包的简化 检查数组越界的方法 为函数参数和字典的 key 提供默认值 检查变量是否在两个数之间 今天的小技巧就到这啦~ 大家觉得有用，不妨在项目中实践一下哦~ 本文首发掘金：你可能不知道的 Swift 开发小技巧——Pt.1 - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的 Swift 代码更 Swift]]></title>
    <url>%2F%E8%AE%A9%E4%BD%A0%E7%9A%84-Swift-%E4%BB%A3%E7%A0%81%E6%9B%B4-Swift%2F</url>
    <content type="text"><![CDATA[引言Swift 有很多其他语言所没有的独特的结构和方法，因此很多刚开始接触 Swift 的开发者并没有发挥它本身的优势。 所以，我们就来看一看那些让你的 Swift 代码更 Swift 的写法吧~ 有条件的 for 循环现在，我们要对view.subviews中的UIButton做一些不可描述的事情，用 for 循环怎么来遍历呢？ 在下面的写法中，更推荐后面两种写法： 12345678910111213141516❌for subView in view.subviews &#123; if let button = subView as? UIButton &#123; //不可描述的事情 &#125;&#125;✅for case let button as UIButton in view.subviews &#123; //不可描述的事情&#125;✅for button in view.subviews where button is UIButton &#123; //不可描述的事情&#125; enumerated()在 Swift 中进行 for 循环，要拿到下标值，一般的写法要么定义局部变量记录下标值，要么遍历 0..&lt;view.subviews.count。其实还有个更方便的写法：enumerated()，可以一次性拿到下标值和遍历的元素。 ❌ 第一种肯定是不推荐的，因为还要定义额外的局部变量，容易出错，pass ✅ 第二种在只需要用到下标值的时候，是可以用的，但如果还要用到下标值对应的元素，就还得再取一次，麻烦，pass ✅ 第三种就比较完美，虽然一次性可以拿到下标值和元素，但其中一个用不到就可以用 _ 12345678910111213141516171819202122232425262728❌var index: Int = 0for subView in view.subviews &#123; //不可描述的事情 index += 1&#125;✅for index in 0..&lt;view.subviews.count &#123; let subView = view.subviews[index] //不可描述的事情&#125;✅//index 和 subView 在循环体中都能使用到for (index, subView) in view.subviews.enumerated() &#123; //不可描述的事情&#125;//只用到 indexfor (index, _) in view.subviews.enumerated() &#123; //不可描述的事情&#125;//只用到 subViewfor (_, subView) in view.subviews.enumerated() &#123; //不可描述的事情&#125; first(where: )filter 是 Swift 中几个高级函数之一，过滤集合中的元素时非常的好用，不过在某些情况下，比如获取集合中满足条件的第一个元素时，有一个更好的选择first(where: ) 1234567891011121314151617let article1 = ArticleModel(title: "11", content: "内容1", articleID: "11111", comments: [])let article2 = ArticleModel(title: "11", content: "内容2", articleID: "22222", comments: [])let article3 = ArticleModel(title: "33", content: "内容3", articleID: "3333", comments: [])let articles = [article1, article2, article3]❌if let article = articles.filter(&#123; $0.articleID == "11111" &#125;).first &#123; print("\(article.title)-\(article.content)-\(article.articleID)")&#125;✅if let article = articles.first(where: &#123;$0.articleID == "11111"&#125;) &#123; print("\(article.title)-\(article.content)-\(article.articleID)") //11-内容1-11111&#125; contains(where: )这个和上面的first(where: )几乎一样，比如这里要判断文章列表里是否包含 articleID 为 11111 的文章： 123456789❌if !articles.filter(&#123; $0.articleID == "11111" &#125;).isEmpty &#123; //不可描述的事情&#125;✅if articles.contains(where: &#123; $0.articleID == "11111"&#125;) &#123; //不可描述的事情&#125; forEach当循环体内的逻辑比较简单时，forEach 往往比 for…in…来的更加简洁： 1234567891011func removeArticleBy(ID: String) &#123; //删库跑路&#125;❌for article in articles &#123; removeArticleBy(ID: $0.articleID)&#125;✅articles.forEach &#123; removeArticleBy(ID: $0.articleID) &#125; 计算属性 vs 方法我们知道计算属性本身不存储数据，而是在 get 中返回计算后的值，在 set 中设置其他属性的值，所以和方法很类似，但比方法更简洁。一起来看下面的示例： 123456789101112131415161718192021222324252627282930313233343536❌class YourManager &#123; static func shared() -&gt; YourManager &#123; //不可描述的事情 &#125;&#125;let manager = YourManager.shared()❌extension Date &#123; func formattedString() -&gt; String &#123; //不可描述的事情 &#125;&#125;let string = Date().formattedString()✅class YourManager &#123; static var shared: YourManager &#123; //不可描述的事情 &#125;&#125;let manager = YourManager.shared✅extension Date &#123; var formattedString: String &#123; //不可描述的事情 &#125;&#125;let string = Date().formattedString 协议 vs 子类化尽量使用协议而不是继承。协议可以让代码更加灵活，因为类可同时遵守多个协议。 此外，结构和枚举不能子类化，但是它们可以遵守协议，这就更加放大了协议的好处 Struct vs Class尽可能使用 Struct 而不是 Class。Struct 在多线程环境中更安全，更快。 它们最主要的区别， Struct 是值类型，而 Classe 是引用类型，这意味着 Struct 的每个实例都有它自己的唯一副本，而 Class 的每个实例都有对数据的单个副本的引用。 这个链接是苹果官方的文档，解释如何在 Struct 和 Class 之间做出选择。https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes。 结语让我们的 Swift 代码更 Swift 的方法远不止上面这些，这里要说的是，平时写代码时，要刻意的使用 Swift 强大的特性，才能发挥它本身的价值。 而这些特性就需要大家去多看看官网的例子，或者一些主流的 Swift 第三方库，看看他们是如何运用 Swift 的特性的。 本文首发掘金：让你的 Swift 代码更 Swift - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5 个让 Swift 更优雅的扩展——Pt.2]]></title>
    <url>%2F5-%E4%B8%AA%E8%AE%A9-Swift-%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E6%89%A9%E5%B1%95%E2%80%94%E2%80%94Pt-2%2F</url>
    <content type="text"><![CDATA[废话不多说，让我们直接开始 5 个让 Swift 更优雅的扩展的第二部分，第一部分的传送门： 5 个让 Swift 更优雅的扩展——Pt.1 3. 自定义操作符先来看一段代码，定义了一个 weak 变量 someViewRef，然后创建、设置属性、添加到父视图上。 可以正常执行，还是会有什么问题？ 123456789101112class ViewController: UIViewController &#123; private weak var someViewRef: UIView? override func viewDidLoad() &#123; super.viewDidLoad() someViewRef = UIView(frame: CGRect(x: 100, y: 50, width: 100, height: 100)) someViewRef?.backgroundColor = .red view.addSubview(someViewRef!) &#125;&#125; 相信大家一眼就看出来了，执行到第一句 someViewRef = UIView(frame: CGRect(x: 100, y: 50, width: 100, height: 100)) 的时候就报错了 第一句：因为 someViewRef 是用 weak 修饰的，所以立马会被释放 第三句：因为被释放，所以 someViewRef 是 nil，强制解包就崩了 所以需要换个思路，我们给抽出来一个函数： 12345678910111213141516class ViewController: UIViewController &#123; private weak var someViewRef: UIView? override func viewDidLoad() &#123; super.viewDidLoad() let someView = assign(someViewRef: &amp;someViewRef, someView: UIView(frame: CGRect(x: 100, y: 50, width: 100, height: 100))) view.addSubview(someView) someViewRef?.backgroundColor = .red &#125; func assign(someViewRef: inout Optional&lt;UIView&gt;, someView: UIView) -&gt; UIView &#123; someViewRef = someView return someView &#125;&#125; 这样一个红色小方块就显示出来了。不过还是有点限制，它只适用于 UIView，我们给它上泛型，把格局打开： 1234func assign&lt;T&gt;(target: inout Optional&lt;T&gt;, value: T) -&gt; T &#123; target = value return value&#125; 这时候我们看下调用: 1let someView = assign(target: &amp;someViewRef, value: UIView(frame: CGRect(x: 100, y: 50, width: 100, height: 100))) 发现 每次都要传入目标变量的引用，&amp;someViewRef，略麻烦。 而且传参 value 时，都是先创建 UIView 实例，再传入，有隐患，我们需要让它延迟执行，进入 assign 方法内部时再创建 大招 CD 已好，我们定义个操作符，像 + - 一样，再利用 @autoclosure 的特性，就有了下面的实现： 123456infix operator &lt;-public func &lt;- &lt;T&gt;(target: inout T?, value: @autoclosure () -&gt; T) -&gt; T &#123; let val = value() target = val return val&#125; 再来看下调用： 1let someView = someViewRef &lt;- UIView() perfect~ 4. 统计集合中某个元素的个数我想大家都遇到过这样的需求，从网络请求数据后，得到一个数组，然后我们要统计里面某个元素有多少个，来看看下面几个常用的方式，你有没有用到过？ 1234567891011121314151617181920let array = ["A", "A", "B", "A", "C"]// 1.var count = 0for value in array &#123; if value == "A" &#123; count += 1 &#125;&#125;// 2.count = 0for value in array where value == "A" &#123; count += 1&#125;// 3.count = array.filter &#123; $0 == "A" &#125;.count// 4... 我们知道获取集合的总个数用.count就可以。为了项目中代码更加统一和可维护性，与其有上面那么多种写法，不如也定义个类似的扩展：count(where:) 12345extension Sequence where Element: Equatable &#123; func count(where isIncluded: (Element) -&gt; Bool) -&gt; Int &#123; self.filter(isIncluded).count &#125;&#125; 我们直接给 Sequence 添加扩展，这样格局就又打开了，像 ArraySlice，也支持。 1234["A", "A", "B"].count(where: &#123; $0 == "A" &#125;) // 2["B", "A", "B"].dropLast(1) // --&gt; ArraySlice&lt;String&gt;.count(where: &#123; $0 == "B" &#125;) // 1 5. 去除集合中指定的重复的对象日常开发中，我想会遇到这样的需求，从网络请求数据得到一个数组，现在需要删除其中重复的元素，同时保证原有的顺序。先看第一种方法： 第一种，内部元素是可哈希的 123456extension Sequence where Element: Hashable &#123; func uniqued() -&gt; [Element] &#123; var seen = Set&lt;Element&gt;() return filter &#123; seen.insert($0).inserted &#125; &#125;&#125; [ 1, 2, 3, 1, 2 ].uniqued() // [ 1, 2, 3 ] 12345678910111213141516171819202122232425262728内部使用了 Set 进行 contains 查找，比数组的 `contains (_:)` 方法时间复杂度要低。- 第二种，内部元素不是可哈希的如果数组内部的元素是解析的 model，而且没有遵守 Hashable，上面的方法就用不了了。```swiftextension Sequence &#123; func uniqued(comparator: (Element, Element) -&gt; Bool) -&gt; [Element] &#123; var result: [Element] = [] for element in self &#123; if result.contains(where: &#123;comparator(element, $0)&#125;) &#123; continue &#125; result.append(element) &#125; return result &#125;&#125;let article1 = ArticleModel(title: &quot;111&quot;, content: &quot;aa&quot;, articleID: &quot;11111&quot;, comments: [])let article2 = ArticleModel(title: &quot;222&quot;, content: &quot;aaa&quot;, articleID: &quot;22222&quot;, comments: [])let article3 = ArticleModel(title: &quot;111&quot;, content: &quot;aaaa&quot;, articleID: &quot;33333&quot;, comments: [])let article4 = ArticleModel(title: &quot;333&quot;, content: &quot;aaaaa&quot;, articleID: &quot;44444&quot;, comments: [])let articles = [article1, article2, article3, article4]let newarticles = articles.uniqued(comparator: &#123;$0.title == $1.title&#125;)print(newarticles) //结果 article3 会被删除 第三种，keypath 版本 最后再来个 keypath 版本，不过是对第二种的一层封装，内部依然调用的是第二种 1234567extension Sequence &#123; func uniqued&lt;T: Equatable&gt;(_ keyPath: KeyPath&lt;Element, T&gt;) -&gt; [Element] &#123; uniqued &#123; $0[keyPath: keyPath] == $1[keyPath: keyPath] &#125; &#125;&#125;let newarticles = articles.uniqued(\.title) 结语通过上面提到的 5 种例子，可见 Swift 的 extension 特性非常的强大且灵活，让代码的可扩展性大大提高。 更多的 extension 用法，大家慢慢探索吧，哈哈哈 本文首发掘金：5 个让 Swift 更优雅的扩展——Pt.2 - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5 个让 Swift 更优雅的扩展——Pt.1]]></title>
    <url>%2F5-%E4%B8%AA%E8%AE%A9-Swift-%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E6%89%A9%E5%B1%95%E2%80%94%E2%80%94Pt-1%2F</url>
    <content type="text"><![CDATA[引言作为开发者，应该编写具有高可维护性和可扩展性的代码。我们可以通过扩展原有的功能，写出更易读，更简洁的代码。 下面就介绍 5 个日常开发中非常实用的扩展。 1. 自定义下标来安全访问数组我想每个开发人员都至少经历过一次index-out-of-bounds的报错。就是数组越界，这个大家都懂，就不过多介绍了。下面是个数组越界的例子： 12345let values = ["A", "B", "C"]values[0] // Avalues[1] // Bvalues[2] // Cvalues[3] // Fatal error: Index out of range 既然是下标超过了数组的大小，那我们在取值之前，先检查下标是否超过数组大小。让我们来看下面的几种方案: 通过 if 来判断下标 123456if 2 &lt; values.count &#123; values[2] // "C"&#125;if 3 &lt; values.count &#123; values[3] // 不会走到这里&#125; 虽然也可以，但显的就很重复繁琐，每次取值之前都要判断一遍下标。 定义公共函数 既然每次都要检查下标，那就把检查下标的逻辑放在一个函数里 12345678910func getValue&lt;T&gt;(in elements: [T], at index: Int) -&gt; T? &#123; guard index &gt;= 0 &amp;&amp; index &lt; elements.count else &#123; return nil &#125; return elements[index]&#125;let values = ["A", "B", "C"]getValue(in: values, at: 2) // "C"getValue(in: values, at: 3) // nil 不仅使用泛型支持了任何类型的元素，当数组越界时，还很贴心的返回了 nil，防止崩溃。 虽然很贴心，但每次取值都要把原数组传进去，显的就很冗余。 extension 既然每次都要传入数组很冗余，那就把数组的参数给去掉。我们知道 Swift 一个很强大的特性就是 extension，我们给 Array定义个 extension，并把这个函数添加进去。 123456789101112extension Array &#123; func getValue(at index: Int) -&gt; Element? &#123; guard index &gt;= 0 &amp;&amp; index &lt; self.count else &#123; return nil &#125; return self[index] &#125;&#125;let values = ["A", "B", "C"]values.getValue(at: 2) // "C"values.getValue(at: 3) // nil subscript 虽然看起来好很多了，但可不可以像原生的取值一样， 一个[]就搞定了呢？of course！ 1234567891011extension Array &#123; subscript (safe index: Int) -&gt; Element? &#123; guard index &gt;= 0 &amp;&amp; index &lt; self.count else &#123; return nil &#125; return self[index] &#125;&#125;values[safe: 2] // "C"values[safe: 3] // nil 自定义的[safe: 2]和原生的 [2]非常的接近了。但自定义的提供了数据越界保护机制。 应用到 Collection 既然这么棒，岂能数组一人独享，我们把它应用到所有 Collection 协议。看起来是不是很优雅~😉 12345extension Collection &#123; public subscript (safe index: Self.Index) -&gt; Iterator.Element? &#123; (startIndex ..&lt; endIndex).contains(index) ? self[index] : nil &#125;&#125; 2. 平等的处理 nil 和空字符串在处理可选值时，我们通常需要将它们与 nil 进行比较进行空检查。当为 nil 时，我们会提供一个默认值让程序继续执行。比如下面这个例子： 123456func unwrap(value: String?) -&gt; String &#123; return value ?? "default value"&#125;unwrap(value: "foo") // foounwrap(value: nil) // default value 但是还有种情况就是空字符串，有时，我们需要把空字符串当做 nil 的情况来处理。此时，不仅要坚持 nil，还要检查空字符串的情况 1234567891011121314func unwrap(value: String?) -&gt; String &#123; let defaultValue = "default value" guard let value = value else &#123; return defaultValue &#125; if value.isEmpty &#123; return defaultValue &#125; return value&#125;unwrap(value: "foo") // foounwrap(value: "") // default valueunwrap(value: nil) // default value 虽然也能解决问题，但依然看起来很臃肿，我们把他简化一下： 1234567func unwrapCompressed(value val: String?) -&gt; String &#123; return val != nil &amp;&amp; !val!.isEmpty ? val! : "default value"&#125;unwrapCompressed(value: "foo") // foounwrapCompressed(value: "") // default valueunwrapCompressed(value: nil) // default value 虽然简化了很多，但不易读，可维护性略差。 可以把空字符串先转化为 nil，再进行处理，这样就和处理 nil 的情况一致了。 12345678910111213141516171819public extension String &#123; var nilIfEmpty: String? &#123; self.isEmpty ? nil : self &#125;&#125;let foo: String? = nilif let value = foo?.nilIfEmpty &#123; print(value) //不会调用&#125;if let value = "".nilIfEmpty &#123; print(value) //不会调用&#125;if let value = "ABC".nilIfEmpty &#123; print(value) //ABC&#125; 总结这里先介绍 5 个常用扩展中的其中 2 个，剩下 3 个且听下回分解啦~ 给集合增加扩展，防止取值越界造成崩溃 给字符串增加扩展，让空字符串变为 nil 如果觉得对你有帮助，不妨在项目中试试吧~ 本文首发掘金：5 个让 Swift 更优雅的扩展——Pt.1 - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构代码的 5 个 Xcode 技巧]]></title>
    <url>%2F%E9%87%8D%E6%9E%84%E4%BB%A3%E7%A0%81%E7%9A%84-5-%E4%B8%AA-Xcode-%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[作为一名开发人员，有时重构代码比写代码的时间都要多，所以知道如何重构一段代码是开发者需要掌握的一项非常重要的技能之一。它还有很多的好处，例如： 有了重构思维，我们从一开始就能有意识的去编写更简洁、更安全的代码 提高代码的可测试性 可以更好的进行 code review 另外，还有专门的书籍和网站去介绍如何进行代码重构。 所以，今天就来分享使用 Xcode 去重构代码的 5 个小技巧。 1. 批量重命名给属性、参数、方法、类取个好名字不仅可以一看到名字就知道是干什么的，还有利于后期的维护和交接，想想如果变量名都是 test1、test2 之类的，当需求变更，再回头看代码，是有多么的糟心。 那如果想给它们更名，但是调用的地方又比较多，需要怎么重命名呢？有同学说全局替换，emmm… 不够优雅，而且容易替换错。 有两种重命名的场景： rename适合全局替换的场景。比如，某个方法被多个类调用。就可以使用 Xcode 自带的 rename 特性。只需要右键重命名的对象，即可调出 rename 特性。 点及 rename 后，Xcode 会搜索所有需要重命名的地方，搜索完成后会高亮显示。编辑高亮部分，点击右上角 rename 就重命名成功啦。 Edit All in Scope适合重命名的对象只在当前文件中被使用。这种情况下，Xcode 只会搜索当前文件内需要重命名的地方，然后高亮显示。修改好后，回车即可重命名成功。 2. Generate Memberwise Initializer特别是处理模块、sdk和一些库的时候，不能完全依赖于初始化程序的自动合成。很多时候，我们需要创建自己的公共初始化器，不过就需要复制粘贴各个属性，比较麻烦。还好，Xcode 有一个方便的特性，可以自动创建按成员变量顺序的初始化器。 右键需要 init 的类型，选择 Refactor，然后再选择 Generate Memberwise Initializer。 Xcode 使用 internal 关键字在类型声明的正下方创建初始化器。我们可以将关键字更改为 public (或者我们需要的值) ，然后在需要的地方剪切和粘贴。 3. Add Missing Switch Cases有时我们定义的枚举的 cases 太多，如果对其遍历，手动写每个 case 势必会很浪费时间。那么有什么方法可以自动填充所有 case 呢？ 对于 OC 来说，在写好 switch 语法后，右键 switch，既可选择 Add Missing Switch Cases 即可自动填充所有 case，真香~ 但是还不够香，对于 Swift 来说，不用写 switch 语法，只需要输入 switch 枚举变量名，回车即可自动填充所有 case。 OC 快被抛弃了😭 4. 多行编辑某些情况下，我们要在不同的代码行编写相同的代码，面向 CV 又不是那么的高大上。这时，我们就可以用非常炫酷的快捷键打法来实现。 比如，下面的演示动画，批量把元素加到当前 view 上。 按住 option + shift 结合鼠标左键选择激活多行编辑 option 和 shift 别松开，点击右键，选中变量 松开 option 和 shift，然后复制粘贴 最后就可以批量输入相同的代码啦~ 没有尝试过的小伙伴，动手试试吧~ 5. Find Call Hierarchy我们在看代码时，有时需要知道函数或变量被调用的所有位置。那么就可以右键方法名称，找到Find Call Hierarchy，在 Xcode 左侧就会出现该方法的调用层级。这样就很方便的知道代码是如何工作的。 结语以上就是在重构和日常开发中，我觉得非常实用的几个小技巧啦。我也觉得熟练的运用开发工具，可以让我们的开发过程更加的舒服。小伙伴们不妨试一试哦~ 也欢迎大家把自己觉得非常好用的一个特性在评论区分享哦~ 本文首发掘金：重构代码的 5 个 Xcode 技巧 - 掘金 (juejin.cn)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 添加全局水印]]></title>
    <url>%2FiOS-%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E6%B0%B4%E5%8D%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>知识小集</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone 强制横竖屏]]></title>
    <url>%2FiPhone-%E5%BC%BA%E5%88%B6%E6%A8%AA%E7%AB%96%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[目前负责的 App 几乎全部页面都是竖屏操作， 所以在 Targets-&gt;General-&gt;Device Orientation 中只勾了Portrait. 但避免不了个别界面需要横屏操作，这就需要 强制切换横竖屏了： 在 AppDelegate 中定义公开属性 var allowRotation: Bool = false 实现 UIApplicationDelegate 的 代理方法： 123456func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; if allowRotation &#123; return .landscape //横屏 &#125; return .portrait //竖屏&#125; 给 UIDevice 添加扩展方法： 123456extension UIDevice &#123; class func switchNew(orientation: UIInterfaceOrientation) &#123; UIDevice.current.setValue(UIInterfaceOrientation.unknown.rawValue, forKey: "orientation") UIDevice.current.setValue(orientation.rawValue, forKey: "orientation") &#125;&#125; 然后在需要 横屏 的控制器中实现以下代码： 123let appDelegate: AppDelegate = UIApplication.shared.delegate as! AppDelegateappDelegate.allowRotation = trueUIDevice.switchNew(orientation: .landscapeLeft) 当从横屏切换到竖屏时，在 竖屏 控制器中实现以下代码: 123let appDelegate: AppDelegate = UIApplication.shared.delegate as! AppDelegateappDelegate.allowRotation = falseUIDevice.switchNew(orientation: .portrait) 以上就是实现强制横竖屏的全部内容啦~ 如有更好的方式来实现，欢迎讨论~]]></content>
      <categories>
        <category>知识小集</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocoaPods指南]]></title>
    <url>%2FcocoaPods%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1、更改软件源 sudo gem update --system 如果提示没权限: Operation not permitted - /usr/bin/update_rubygems使用 sudo gem update -n /usr/local/bin --system gem sources --remove https://rubygems.org/ gem sources -a https://ruby.taobao.org/ gem sources -l 123注：由于淘宝源不再更新，建议替换成Ruby China源：gem sources --remove https://ruby.taobao.org/gem sources -a https://gems.ruby-china.org/ 2、安装CocoaPodssudo gem install cocoapods 如果提示无权限，使用：sudo gem install -n /usr/local/bin cocoapods 3、pod初始化 普通⽅方式:(速度慢) pod setup 更改CocoaPods镜像索引(速度快⼀一点) 12pod repo remove masterpod repo add master http://git.oschina.net/akuandev/Specs.git pod repo update 4、使⽤用CocoaPods 在程序的跟路径新建⽂文件 Podfile 编辑 Podfile,添加此项目需要的开源类库 在终端cd到程序跟路径,执行 pod install 安装开源类库 123注意,需要记住如下 2 点即可:使用 CocoaPods ⽣成的 .xcworkspace ⽂件来打开工程,⽽不是以前的 .xcodeproj 文件 每次更改了 Podfile文件,你需要重新执行一次 pod update (--verbose --no-repo-update) 命令 5、查找第三⽅方类库pod search AFNetworking 6、关于 Podfile.lock​ 当你执行 pod install 之后,除了 Podfile 外, CocoaPods 还会⽣成一个名为 Podfile.lock 的文件,Podfile.lock 应该加⼊到版本控制里面,不应该把这个文件加⼊到 .gitignore 中,这样多人协作的时候,可以防止第三⽅库升级时造成大家各自的第三⽅库版本不一致 7、pod install 和 pod update 的区别这是英文原文链接 这是翻译版本]]></content>
      <categories>
        <category>cocoaPods</category>
      </categories>
      <tags>
        <tag>cocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pod install & pod update]]></title>
    <url>%2Fpod-install-pod-update%2F</url>
    <content type="text"><![CDATA[原文链接：https://guides.cocoapods.org/using/pod-install-vs-update.html 译者：Soledad、DamonLu 微博：@CaiYue_ 介绍很多人刚接触 CocoaPods 时都会觉得 pod install 只在第一次给项目配置 CocoaPods 的时候使用，pod update 只在之后使用。然而 压根就不是那样的。（译者注：原文中还提到这里的install和update的含义和字典中的意思不完全相同，要具体问题具体分析，根据相关文档来判断。） 这篇文章的目的就是向你解释什么时候该用 pod install 和 pod update 。 TL;DR: 在你的项目里安装新pods时使用 pod install。即使你已经有 Podfile 和曾经运行过 pod install指令，所以即使你在已经使用CoacoPods的项目中刚刚增添／移除 pods，你也应当使用该命令。 只在你想让pods升级到新版本时才使用 pod update。 具体使用场景pod install当你第一次你想获取pods项目时，以及当你每次编辑你的 Podfile 来增加、更新或者移除某个pod的时候。 每当你运行 pod install 指令时——下载和安装pods时——CocoaPods都会把每个安装的pods的版本，写在 Podfile.lock 文件里。这个文件跟踪纪录了安装了的pods的版本信息并锁住版本。 当你运行 pod install 时，它只安装没有列在 Podfile.lock 里的pods。 对于已经列在 Podfile.lock 中的pods，它会下载 Podfile.lock 中列的确切的版本，而不会去检查这些pods是否有新的可用版本。 对于那些还没有列在 Podfile.lock 中的pods，它会寻找满足 Podfile 中约束条件的pods（例如 pod ‘MyPod’,’~&gt;1.2’） pod outdated当你运行 pod outdated ，CocoaPods 会列出所有 Podfile.lock 文件中已经过时的pods。也就是说，如果你运行 pod update PODNAME （PODNAME为列出的pods名称），它们将会被更新（只要它们满足 Podfile 中满足的约束条件。） pod update当你运行 pod update PODNAME，CoacoPods将会试着去找名为 PODNAME 的pod的更新版本，而不考虑 Podfile.lock 文件中的内容。它会将该pod更新至最新版本（同时只要它满足Podfile中的约束），并且也会相应的更新 Podfile.lock 中的内容。 如果你运行 pod update ，不加任何参数，CocoaPods将会把所有在 Podfile 中列举的pods更新到最新版本。 推荐用法使用 pod update PODNAME，你将只能够更新一个特定的pod（检查是否有新版本并且更新）。而不是像 pod install 那样不去尝试更新已安装的pods。 当你把pod加入到 Podfile 后，你应当运行 pod install 而不是 pod update。 也就是说，只有当你想去升级特定pod（或是全部pods）的时候才用 pod update [PODNAME]。 把你的 Podfile.lock 加入到版本控制中 作为提醒，即使我们不需要把Pods项目上传到版本管理的仓库中，我们也应当始终commit &amp; push 我们的 Podfile.lock 文件。 否则，它会打破上面解释的关于pod install能够锁定已安装版本的pod 的整个逻辑 译者注原文末尾还举了一个实际中应用 pod install 和 pod update 的例子，并提了一个不要在Podfile中写死特定版本的建议。链接戳此https://guides.cocoapods.org/using/pod-install-vs-update.html。 场景示例以下是一个场景示例，用于说明在项目生命周期中可能遇到的各种用例。 阶段1：User1 创建项目 USER1创建一个项目，想用pods A，B，C。他们用这些pods 创建了一个Podfile文件，然后运行pod install。 这将会安装pods A，B，C，他们都在版本1.0.0。 该Podfile.lock会跟踪并标记A，B，C的版本为1.0.0。 顺便说一下，因为这是第一次运行pod install，并且Pods.xcodeproj项目尚不存在，该命令还会创建Pods.xcodeproj和 .xcworkspace，但这只是该命令的额外产生的，不是主要功能。 阶段2：User1 添加一个新的pod稍后，user1想要将pod D添加到Podfile。 因此，他们应该在之后运行pod install，即使pod B的主要人员在第一次执行pod intall后发布了pod的1.1.0版本，该项目仍会继续使用1.0.0版本 - 因为user1只想要添加pod D，不想更新pod B。 这就是有些人错误的地方，因为他们在这使用 pod update - 可能会认为“我想用新的pod 来更新项目”？- 而不是使用pod install- 在项目中安装新的pod。 阶段3：User2 加入该项目然后，从未参与过该项目的用户2加入该团队。他们克隆仓库然后使用pod install。 Podfile.lock（应该提交到git仓库）的内容将确保他们将获得完全相同的pods，并且使用与user1完全相同的版本。 即使1.2.0版本的C现在可用，user2也将获得1.0.0版本的C. 因为这是在Podfile.lock中注册的内容。 pod C被Podfile.lock锁定为版本1.0.0（该文件因此得名）。 阶段4：检查pod的新版本稍后，user1需要检查pods是否有可用的更新。他们运行pod outdated这将告诉他们，pod B有一个新1.1.0版本，并且pod C有一个新1.2.0版本。 user1决定他们想更新pod B，而不是pod C; 所以他们运行pod update B，它将B从版本1.0.0更新到版本1.1.0（并相应地更新Podfile.lock），但会保持C版本1.0.0（不会更新到1.2.0）。 在Podfile中使用精确的版本是不够的有些人可能会认为，通过在Podfile中指定Pod的精确版本，例如pod ‘A’，’1.0.0’，足以保证每个用户都拥有与团队中其他人相同的版本。 然后，他们甚至可以使用pod update，即使只是添加一个新Pod，也认为从来不会有风险更新其他Pod，因为他们在Podfile中固定了pod版本。 但事实上，这还不足以保证我们上述场景中的user1和user2将始终获得完全相同版本的所有Pod。 一个典型的例子是，如果pod A依赖于pod A2 - 在A.podspec中声明为依赖关系’A2’，’〜&gt; 3.0’。在这种情况下，在Podfile中使用pod’A’，’1.0.0’，确实会强制user1和user2都使用pod A的版本1.0.0，但是： 而当user2稍后加入项目时运行pod install时，他们可能会在版本3.5中获得pod A2（因为A2的维护者可能同时发布了新版本）。这就是为什么确保每个团队成员使用每台计算机上所有pod的相同版本的唯一方法是使用Podfile.lock并正确使用pod安装与pod更新。 user1最终可能会在版本3.4中得到A2（因为那时是A2的最新版本） 而当user2加入项目后，运行pod install时，他们可能会在版本3.5中获得pod A2（因为A2的维护者可能同时发布了新版本）。 这就是为什么确保每个团队成员使用每台计算机上所有pod的相同版本的唯一方法是使用Podfile.lock并正确使用pod install与pod update。]]></content>
      <categories>
        <category>cocoaPods</category>
      </categories>
      <tags>
        <tag>cocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
